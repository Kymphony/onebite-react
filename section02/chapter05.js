/*
원시타입 VS 객체타입

원시타입: Number, String, Boolean, Null, Undefined
객체타입: Object - Array, Function, RegexExp

자바스크립트가 원시타입과 객체타입을 나눈 이유:
원시 타입과 객체 타입은 값이 저장되거나 복사되는 과정이 서로 다르기 때문
원시 타입: 값 자체로써 변수에 저장되고 복사된다. (메모리에 그대로 값 할당)
객체 타입: 값 자체가 아닌 값에 접근할 수 있는 주소값(참조값)을 통해 변수에 저장되고 복사된다.
*/

// 원시 타입의 값 할당
let p1 = 1; // 메모리에 1값 할당. p1은 1이 저장된 메모리를 보도록 지정
let p2 = p1; // 마찬가지로 메모리에 1값 할당. p2는 1이 저장된 메모리를 보도록 지정
p2 = 2; // 메모리의 다른 공간에 2값 할당(1값은 삭제되거나 덮어씌워지지 않고 그대로 남아있음). 변수 p2가 2를 보도록 수정.
// 즉, 원시 타입 변수에 한번 할당된 값은 메모리에 그대로 남아 변하지 않기 때문에 원시타입을 "불변값" 이라고도 한다.

// 객체 타입의 값 할당
let o1 = { name: "김성원" };
// 메모리에 "name: 김성원" 값 할당. 그러나 o1 변수는 해당 메모리를 바로 보는것이 아니라 Ox0000C라는 메모리의 주소값을 바라보게 된다.
let o2 = o1;
// 메모리에 새로운 값이 할당되지 않고 객체타입 o2가 마찬가지로 Ox0000C 를 바라보도록 지정한다.
o1.name = "김주애";
// 메모리에 새로 값이 할당되는 원시타입 값과 달리 객체타입은 메모리에서 "name: 김성원"을 직접 수정하여 "name: 김주애"로 바꿔버린다.
// 그래서 객체타입 값을 "가변값"으로 부른다.

// 객체 타입 주의사항 1. 의도치 않게 값이 수정될 수 있다. (o1 객체 프로퍼티 수정시 o2 객체에도 영향이 생긴다.)
let o3 = { ...o1 }; // 이렇게 하면 참조값만 복사(얕은 복사)하는게 아니라 새로운 객체를 생성하면서 프로퍼티만 따로 복사한다.(깊은 복사)

// 객체 타입 주의사항 2. 객체간의 비교는 참조값을 기준으로 이루어진다.
let oA = { name: "김성원" };
let oB = oA;
let oC = { ...oA };

console.log(oA === oB); // true
console.log(oA === oC); // false
console.log(JSON.stringify(oA) === JSON.stringify(oC)); // true. JSON.stringify(): 객체를 문자열로 변환해주는 자바스크립트 내장 함수.

// 객체 타입 주의사항 3. 배열과 함수도 사실 객체이다.
// 프로퍼티와 메서드를 가질 수 있다.
